(* Proverif code of X3-ECDH in Matrix protocol *)
free ch:channel.

(* type defination *)
type key.
type pkey.
type skey.
fun pk(skey): pkey.
type number.
type sharedkey.
type iv.

(* OLM constant value *)
const INFO: bitstring.
const SALT: bitstring.
const length: number.
const PADDING_1: bitstring.
const PADDING_2: bitstring.

(* OLM Algorithm tables used to pass data between steps *)
table table1_client_alice(skey, skey, pkey, pkey, pkey, pkey, key).
table table1_client_bob(skey, skey, pkey, pkey, pkey, pkey, key).
table table1_server_alice(pkey, pkey, pkey, pkey).
table table1_server_bob(pkey, pkey, pkey, pkey).

(* Concatenation helper functions *)
fun concat3(bitstring, bitstring, bitstring): bitstring.
fun first_part3(bitstring): bitstring.
equation forall b1: bitstring, b2: bitstring, b3: bitstring; first_part3(concat3(b1, b2, b3)) = b1.

fun concat2(bitstring, bitstring): bitstring.
fun first_part2(bitstring): bitstring.
equation forall b1: bitstring, b2: bitstring; first_part2(concat2(b1, b2)) = b1.

(* Helper functions to get bits from a bitstring *)
fun fist256bit(bitstring): bitstring.
fun next256bit(bitstring): bitstring.
fun last128bit(bitstring): bitstring.

(* Elliptic Curve Diffieâ€“Hellman Key Exchange. *)
(* https://cryptobook.nakov.com/asymmetric-key-ciphers/ecdh-key-exchange *)
type G.
type scalar.
type basis.
const P:G [data].
(* fun Ggen(basis):G. *)
fun sca(scalar, G):G.
equation forall x:scalar, y:scalar; 
	sca(x, sca(y, P))= sca(y, sca(x, P)).

(* type conversion functions *)
fun private_key2scalar(skey): scalar [typeConverter].
fun public_key2G(pkey): G [typeConverter].
fun G2bitstring(G): bitstring [typeConverter].
fun bitstring2key(bitstring): key [typeConverter].

(* sharedkey calculation *)
letfun get_ecdhkey(pk_E_remote:pkey, sk_I_local:skey) = sca(private_key2scalar(sk_I_local), public_key2G(pk_E_remote)).
letfun get_ecdhkey_1(sk_I_local:skey, pk_E_remote:pkey) = sca(private_key2scalar(sk_I_local), public_key2G(pk_E_remote)).
letfun get_ecdhkey_2(sk_E_local:skey, pk_I_remote:pkey) = sca(private_key2scalar(sk_E_local), public_key2G(pk_I_remote)).
letfun get_ecdhkey_3(sk_E_local:skey, pk_E_remote:pkey) = sca(private_key2scalar(sk_E_local), public_key2G(pk_E_remote)).

(* Replay Attack events *)
event clientReplayAttack_A(key, iv).
event clientReplayAttack_B(key, iv).


(* step 1 ECDH key exchange in client Alice *)
let step1clientA(skey_A_I:skey, skey_A_E:skey) =
(	
	(* Identity keys *)
	let pk_A_I = pk(skey_A_I) in
	(* One-time keys *)
	let pk_A_E = pk(skey_A_E) in
	
	out(ch, (pk_A_I,pk_A_E));
	in(ch, (pk_B_I:pkey, pk_B_E:pkey));
	
	let ecdhkey_AB_1 = get_ecdhkey_1(skey_A_I, pk_B_E) in
	let ecdhkey_AB_2 = get_ecdhkey_2(skey_A_E, pk_B_I) in
	let ecdhkey_AB_3 = get_ecdhkey_3(skey_A_E, pk_B_E) in
	let SharedSecret_AB = concat3(G2bitstring(ecdhkey_AB_1), G2bitstring(ecdhkey_AB_2), G2bitstring(ecdhkey_AB_3)) in
	
	insert table1_client_alice(skey_A_I, skey_A_E, pk_A_I, pk_A_E, pk_B_I, pk_B_E, bitstring2key(SharedSecret_AB))
).

(* step 1 ECDH key exchange in homeserver Alice *)
let step1serverA() =
(
	in(ch, (pk_A_I:pkey, pk_A_E:pkey));
	out(ch, (pk_A_I, pk_A_E));
	
	in(ch, (pk_B_I:pkey, pk_B_E:pkey));
	out(ch, (pk_B_I,pk_B_E));
	
	insert table1_server_alice(pk_A_I, pk_A_E, pk_B_I, pk_B_E)
).

(* step 1 ECDH key exchange in homeserver Bob *)
let step1serverB() =
(
	in(ch, (pk_A_I:pkey, pk_A_E:pkey));
	out(ch, (pk_A_I,pk_A_E));
	
	in(ch, (pk_B_I:pkey, pk_B_E:pkey));
	out(ch, (pk_B_I,pk_B_E));
	
	insert table1_server_bob(pk_B_I, pk_B_E, pk_A_I, pk_A_E)
).

(* step 1 ECDH key exchange in client Bob *)
let step1clientB(skey_B_I:skey, skey_B_E:skey) =
(
	in(ch, (pk_A_I:pkey, pk_A_E:pkey));
		
	(* Identity keys *)
	let pk_B_I = pk(skey_B_I) in
	(* One-time keys *)
	let pk_B_E = pk(skey_B_E) in
	
	out(ch, (pk_B_I,pk_B_E));
		
	let ecdhkey_AB_1 = get_ecdhkey_1(skey_B_I, pk_A_E) in
	let ecdhkey_AB_2 = get_ecdhkey_2(skey_B_E, pk_A_I) in
	let ecdhkey_AB_3 = get_ecdhkey_3(skey_B_E, pk_A_E) in
	let SharedSecret_BA = concat3(G2bitstring(ecdhkey_AB_1), G2bitstring(ecdhkey_AB_2), G2bitstring(ecdhkey_AB_3)) in
	
	insert table1_client_bob(skey_B_I, skey_B_E, pk_B_I, pk_B_E, pk_A_I, pk_A_E, bitstring2key(SharedSecret_BA))
).


(* OLM defined functions from Matrix spec *)
fun HKDF(bitstring, key, bitstring, nat): bitstring.
fun HMAC_SHA256(key, bitstring): key.

(* IKM: input keying material, OKM: output keying material *)
letfun h1(SALT: bitstring, IKM: key, INFO: bitstring, LENGTH: nat) = 
let OKM = HKDF(SALT, IKM, INFO, LENGTH) in 
(fist256bit(OKM), next256bit(OKM)).

letfun h2(SALT: bitstring, IKM: key, INFO: bitstring, LENGTH: nat) = 
let OKM = HKDF(SALT, IKM, INFO, LENGTH) in 
(fist256bit(OKM), next256bit(OKM), last128bit(OKM)).

(* AES-CBC *)
fun senccbc(bitstring, key, iv): bitstring.
reduc forall m:bitstring, k: key, i: iv; sdeccbc(senccbc(m, k, i), k, i) = m.

(* Client send sensitive data *)
free plain_text_A: bitstring [private].
free plain_text_B: bitstring [private].

(* step 2 client Alice encrypt message and send it. *)
let step2clientA(index:nat, ratchetKey_A:skey) = 
(
	get table1_client_alice(skey_A_I, skey_A_E, pk_A_I, pk_A_E, pk_B_I, pk_B_E, SharedSecret_AB) in 
		
	(* ------------------------------------------------------- *)
	(* generate keys, encrypt plain_text_A, and send ciper-text. *)
	(* ------------------------------------------------------- *)
	(* generate root key, chain key, and ratchet key, and messgae key *)
	let (rootKey: key, chainKey: key) = h1(SALT, SharedSecret_AB, INFO, 64) in
	let msgKey = HMAC_SHA256(chainKey, PADDING_1) in 
	
	(* encrypt plain-text with the message key using an authenticated encryption scheme *)
	let LENGTH = 80 in
	let (aesKey: key, hmacKey: key, aesIV: iv) = h2(SALT, msgKey, INFO, LENGTH) in	
	event clientReplayAttack_A(aesKey, aesIV);
	let cipher_text_A = senccbc(plain_text_A, aesKey, aesIV) in
	
	(* send public part of ratchet key, chain index, cipher-text *)	
	out(ch, (cipher_text_A, pk(ratchetKey_A), pk_A_I, pk_A_E, SALT, INFO, LENGTH));
	out(ch, index)
).

(* step 2 server Alice receive cipher-text, public part of ratchet key, and index, send it *)
let step2serverA() =
(	
	get table1_server_alice(pk_A_I, pk_A_E, pk_B_I, pk_B_E) in
	
	(* receive data from Alice client *)
	in(ch, (cipher_text_A:bitstring, pk_ratchetKey_A:pkey, pk_A_I:pkey, pk_A_E:pkey, SALT:bitstring, INFO:bitstring, LENGTH:nat));
	in(ch, index:nat);

	out(ch, (cipher_text_A, pk_ratchetKey_A, pk_A_I, pk_A_E, SALT, INFO, LENGTH));
	out(ch, index)
). 


(* step 2 server Bob receive cipher-text, public part of ratchet key, and index, send it  *)
let step2serverB() =
(
	get table1_server_bob(pk_B_I, pk_B_E, pk_A_I, pk_A_E) in
	
	(* receive data from Alice server *)
	in(ch, (cipher_text_A:bitstring, pk_ratchetKey_A:pkey, pk_A_I:pkey, pk_A_E:pkey, SALT:bitstring, INFO:bitstring, LENGTH:nat));
	in(ch, index:nat);

	out(ch, (cipher_text_A, pk_ratchetKey_A, pk_A_I, pk_A_E, SALT, INFO, LENGTH));
	out(ch, index)
).

(* step 2 client Bob decrypt message. *)
let step2clientB(ratchetKey_B:skey) = 
(
	get table1_client_bob(skey_B_I, skey_B_E, pk_B_I, pk_B_E, pk_A_I, pk_A_E, SharedSecret_BA) in 
	
	(* --------------------------------------------------------------------------- *)
	(* generate keys, receive Alice keys, and decrypt ciper-text. *)
	(* --------------------------------------------------------------------------- *)
	(* generate root key, chain key, and ratchet key, and messgae key *)
	let (rootKey: key, chainKey: key) = h1(SALT, SharedSecret_BA, INFO, 64) in
	let msgKey = HMAC_SHA256(chainKey, PADDING_1) in 
	
	(* receive Alice keys, and decrypt ciper-text *)
	in(ch, (cipher_text_A:bitstring, pk_ratchetKey_A:pkey, pk_A_I:pkey, pk_A_E:pkey, SALT:bitstring, INFO:bitstring, LENGTH:nat));
	in(ch, index:nat);
	
	let (aesKey: key, hmacKey: key, aesIV: iv) = h2(SALT, msgKey, INFO, LENGTH) in	
	let plain_text_A = sdeccbc(cipher_text_A, aesKey, aesIV) in
	event clientReplayAttack_B(aesKey, aesIV)
).

(* Queries - confidentiality properties *)
query aesKey:key, i:iv; event(clientReplayAttack_B(aesKey, i)) ==> event(clientReplayAttack_A(aesKey, i)).

query attacker(plain_text_A).

process

  new skey_A_I:skey; 
  new skey_B_I:skey; 
  new skey_A_E:skey;
  new skey_B_E:skey;
  
  new ratchetKey_A: skey;
  new ratchetKey_B: skey;
  
( 
  (!step1clientA(skey_A_I, skey_A_E)) | (!step1clientB(skey_B_I, skey_B_E)) | (!step2clientA(0, ratchetKey_A)) | (!step2clientB(ratchetKey_B))
)